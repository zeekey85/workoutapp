<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workout Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .table-cell-input { width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 0.375rem; background-color: #f9fafb; }
        .table-cell-input:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in-animation { animation: fadeIn 0.5s ease-out forwards; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Workout Tracker</h1>
            <p class="text-gray-600 mt-2">Load a plan and track your workout. Progress is saved automatically.</p>
            <a href="index.html" class="text-blue-600 hover:underline">Go to Planner</a>
            <a href="analysis.html" class="text-blue-600 hover:underline ml-4">Go to Analysis</a>
        </header>

        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 p-4 bg-white rounded-xl shadow-md border mb-8">
            <select id="user-filter-select" class="px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 w-full sm:w-auto">
                <option value="">-- Select User --</option>
                <option value="Zak">Zak</option>
                <option value="Kate">Kate</option>
            </select>
            <button id="filter-plans-button" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 w-full sm:w-auto">Load User's Workouts</button>
            <select id="plan-selector" class="px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 w-full sm:w-auto">
                <option value="">-- Select a User First --</option>
            </select>
            <button id="load-plan-button" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 w-full sm:w-auto">
                Load Selected Workout
            </button>
        </div>
        <div class="text-center"><p id="statusMessage" class="text-sm font-medium h-5"></p></div>

        <main id="workout-tracker-container" class="space-y-6 mt-6">
            <div id="empty-state" class="text-center py-16 text-gray-500 bg-white rounded-xl shadow-lg border">
                <p class="text-lg font-semibold">No workout loaded.</p>
                <p class="text-sm">Select a user and workout from the dropdowns and click "Load".</p>
            </div>
        </main>
        
        <!-- Action buttons container -->
        <div id="action-buttons" class="mt-8 flex flex-col sm:flex-row justify-center items-center gap-4 hidden">
             <button id="save-progress-button" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 w-full sm:w-auto">
                Save Progress
            </button>
            <button id="complete-workout-button" class="px-6 py-3 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 w-full sm:w-auto">
                Complete Workout
            </button>
        </div>

    </div>

    <script type="module">
        // --- CONFIGURATION ---
        const LIST_WORKOUTS_URL = `/api/list_workouts_for_tracker`;
        const GET_WORKOUT_URL = `/api/get_workout`;
        const SAVE_WORKOUT_URL = `/api/save_workout`;
        const COMPLETE_WORKOUT_URL = `/api/complete_workout`; // NEW

        // --- DOM ELEMENTS ---
        const userFilterSelect = document.getElementById('user-filter-select');
        const filterPlansButton = document.getElementById('filter-plans-button');
        const planSelector = document.getElementById('plan-selector');
        const loadPlanButton = document.getElementById('load-plan-button');
        const statusMessage = document.getElementById('statusMessage');
        const trackerContainer = document.getElementById('workout-tracker-container');
        const emptyState = document.getElementById('empty-state');
        const actionButtons = document.getElementById('action-buttons');
        const saveProgressButton = document.getElementById('save-progress-button');
        const completeWorkoutButton = document.getElementById('complete-workout-button');

        // --- STATE ---
        let allServerWorkouts = { plans: [], tracked: [] };
        let sourcePlanFilename = null; // The original plan file, e.g., 'Zak_Upper_2025-07-08.csv'
        let trackedFilename = null;    // The in-progress file, e.g., 'Zak_Upper_2025-07-08_tracked.csv'

        // --- EVENT LISTENERS ---
        window.addEventListener('load', loadWorkoutListFromServer);
        filterPlansButton.addEventListener('click', filterAndDisplayWorkouts);
        loadPlanButton.addEventListener('click', handleLoadWorkout);
        saveProgressButton.addEventListener('click', () => autoSaveProgress(true)); // Manual save
        completeWorkoutButton.addEventListener('click', handleCompleteWorkout);

        // --- FUNCTIONS ---

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        const debouncedAutoSave = debounce(autoSaveProgress, 1500);

        async function loadWorkoutListFromServer() {
            showStatus('Loading workouts from server...', 'blue');
            try {
                const response = await fetch(LIST_WORKOUTS_URL);
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`);
                const data = await response.json();
                if (data.status === 'success') {
                    allServerWorkouts = data;
                    showStatus('Ready. Select a user to see their workouts.', 'green');
                } else {
                    showStatus('No workouts found on the server.', 'orange');
                }
            } catch (error) {
                console.error('Failed to load workout list:', error);
                showStatus('Error: Could not connect to server to load workouts.', 'red');
            }
        }
        
        function filterAndDisplayWorkouts() {
            const userName = userFilterSelect.value;
            if (!userName) { showStatus('Please select a user.', 'orange'); return; }

            const userPlans = allServerWorkouts.plans.filter(p => p.toLowerCase().startsWith(userName.toLowerCase() + '_'));
            const userTracked = allServerWorkouts.tracked.filter(t => t.toLowerCase().startsWith(userName.toLowerCase() + '_'));
            
            planSelector.innerHTML = '<option value="">-- Select a Workout --</option>';

            if (userTracked.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'In-Progress Workouts';
                userTracked.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.dataset.type = 'tracked';
                    option.textContent = file;
                    optgroup.appendChild(option);
                });
                planSelector.appendChild(optgroup);
            }

            if (userPlans.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'New Workout Plans';
                userPlans.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.dataset.type = 'plan';
                    option.textContent = file;
                    optgroup.appendChild(option);
                });
                planSelector.appendChild(optgroup);
            }

            if (userPlans.length === 0 && userTracked.length === 0) {
                planSelector.innerHTML = '<option value="">-- No workouts found for this user --</option>';
                showStatus(`No workouts found for ${userName}.`, 'orange');
            } else {
                showStatus(`Found ${userTracked.length} in-progress and ${userPlans.length} new plan(s) for ${userName}.`, 'green');
            }
        }

        async function handleLoadWorkout() {
            const selectedOption = planSelector.options[planSelector.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                showStatus('Please select a workout to load.', 'orange');
                return;
            }

            const filename = selectedOption.value;
            const type = selectedOption.dataset.type;
            showStatus(`Loading ${filename}...`, 'blue');

            try {
                const response = await fetch(`${GET_WORKOUT_URL}?filename=${filename}&type=${type}`);
                if (!response.ok) throw new Error(`Could not fetch file. Status: ${response.status}`);
                const csvText = await response.text();
                
                let workoutData;
                if (type === 'plan') {
                    sourcePlanFilename = filename;
                    trackedFilename = filename.replace('.csv', '_tracked.csv');
                    workoutData = parsePlanCSV(csvText);
                } else { // type === 'tracked'
                    trackedFilename = filename;
                    sourcePlanFilename = filename.replace('_tracked.csv', '.csv'); 
                    workoutData = parseTrackedCSV(csvText);
                }

                if (workoutData) {
                    displayWorkoutTracker(workoutData);
                    showStatus(`Loaded ${filename}. Ready to track!`, 'green');
                }
            } catch (error) {
                console.error('Failed to load workout content:', error);
                showStatus('Error loading the selected workout.', 'red');
            }
        }

        function parsePlanCSV(csvText) {
            const rows = csvText.trim().split('\n');
            if (rows.length < 2) { showStatus("Error: Plan CSV is empty or invalid.", 'red'); return null; }
            rows.shift();
            return rows.map(row => {
                const values = row.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g).map(v => v.replace(/"/g, ''));
                const sets = parseInt(values[1], 10);
                return { 
                    name: values[0], sets, targetReps: values[2], weight: parseFloat(values[3]), 
                    supersetGroup: values[4], coachNotes: values[5] || '',
                    setsData: Array.from({ length: sets }, () => ({ reps: '', actualWeight: '', notes: '', rir: '' }))
                };
            });
        }

        function parseTrackedCSV(csvText) {
            const rows = csvText.trim().split('\n');
            if (rows.length < 2) { showStatus("Error: Tracked CSV is empty or invalid.", 'red'); return null; }
            const header = rows.shift().toLowerCase().split(',').map(h => h.trim().replace(/"/g, ''));
            
            const exercises = new Map();
            rows.forEach(row => {
                const values = row.split(',').map(v => v.trim().replace(/"/g, ''));
                const exerciseName = values[header.indexOf('exercise')];
                
                if (!exercises.has(exerciseName)) {
                    exercises.set(exerciseName, {
                        name: exerciseName,
                        targetReps: values[header.indexOf('target reps')],
                        weight: parseFloat(values[header.indexOf('target weight (kg)')]),
                        supersetGroup: values[header.indexOf('superset group')],
                        coachNotes: values[header.indexOf('coach\'s notes')].replace(/""/g, '"'),
                        setsData: []
                    });
                }
                
                exercises.get(exerciseName).setsData.push({
                    reps: values[header.indexOf('actual reps')],
                    actualWeight: values[header.indexOf('actual weight (kg)')],
                    notes: values[header.indexOf('notes')].replace(/""/g, '"'),
                    rir: values[header.indexOf('reps in reserve (rir)')]
                });
            });
            return Array.from(exercises.values());
        }

        function displayWorkoutTracker(trackingData) {
            emptyState.style.display = 'none';
            trackerContainer.innerHTML = '';
            trackingData.forEach((exercise) => {
                const exerciseElement = document.createElement('div');
                let bgColorClass = 'bg-white';
                if (exercise.supersetGroup === 'A') bgColorClass = 'bg-blue-50';
                if (exercise.supersetGroup === 'B') bgColorClass = 'bg-yellow-50';
                exerciseElement.className = `exercise-container ${bgColorClass} p-4 sm:p-6 rounded-xl shadow-lg border fade-in-animation`;
                
                let coachNotesHTML = exercise.coachNotes ? `<blockquote class="mt-2 mb-4 p-3 border-l-4 border-purple-300 bg-purple-50 text-purple-800">${exercise.coachNotes}</blockquote>` : '';

                let tableHTML = `
                    <div class="flex justify-between items-baseline mb-2">
                        <h3 class="text-xl sm:text-2xl font-bold">${exercise.name}</h3>
                        <div class="text-right">
                            <p class="text-sm text-gray-600">Target: <span class="font-semibold">${exercise.setsData.length} sets @ ${exercise.weight || 0} kg</span></p>
                            ${exercise.supersetGroup !== 'None' ? `<p class="text-sm font-bold text-indigo-600">Superset ${exercise.supersetGroup}</p>` : ''}
                        </div>
                    </div>
                    ${coachNotesHTML}
                    <table class="w-full text-left">
                        <thead><tr class="border-b"><th class="p-2 w-1/12">Set</th><th class="p-2 w-3/12">Actual Reps</th><th class="p-2 w-3/12">Actual Weight (kg)</th><th class="p-2 w-4/12">Notes</th><th class="p-2 w-1/12">RIR</th></tr></thead>
                        <tbody>`;
                
                exercise.setsData.forEach((setData, setIndex) => {
                    tableHTML += `<tr class="border-b border-gray-200"><td class="p-2 font-semibold">Set ${setIndex + 1}</td><td class="p-2"><span class="text-xs text-gray-500 block">Goal: ${exercise.targetReps}</span><input type="number" class="table-cell-input reps-input" placeholder="Reps" value="${setData.reps || ''}"></td><td class="p-2"><span class="text-xs text-gray-500 block">Goal: ${exercise.weight || 0} kg</span><input type="number" class="table-cell-input weight-input" placeholder="Weight" value="${setData.actualWeight || ''}"></td><td class="p-2"><input type="text" class="table-cell-input notes-input" placeholder="e.g., good form" value="${setData.notes || ''}"></td><td class="p-2"><input type="number" class="table-cell-input rir-input" placeholder="RIR" value="${setData.rir || ''}"></td></tr>`;
                });
                tableHTML += `</tbody></table>`;
                exerciseElement.innerHTML = tableHTML;
                trackerContainer.appendChild(exerciseElement);
            });

            trackerContainer.querySelectorAll('.table-cell-input').forEach(input => {
                input.addEventListener('input', () => debouncedAutoSave(false));
            });
            
            actionButtons.classList.remove('hidden');
        }
        
        async function autoSaveProgress(isManual = false) {
            if (!trackedFilename) return;

            const trackingData = readDataFromUI();
            if (trackingData.length === 0) { 
                if(isManual) showStatus('Nothing to save.', 'orange'); 
                return; 
            }
            
            let csvContent = "Exercise,Target Reps,Target Weight (kg),Superset Group,Coach's Notes,Set,Actual Reps,Actual Weight (kg),Notes,Reps in Reserve (RIR)\r\n";
            trackingData.forEach(exercise => {
                const coachNotes = `"${(exercise.coachNotes || '').replace(/"/g, '""')}"`;
                exercise.setsData.forEach((setData, index) => {
                    const userNotes = `"${(setData.notes || '').replace(/"/g, '""')}"`;
                    csvContent += [`"${exercise.name}"`, `"${exercise.targetReps}"`, exercise.weight, exercise.supersetGroup, coachNotes, index + 1, setData.reps, setData.actualWeight, userNotes, setData.rir].join(',') + '\r\n';
                });
            });

            const payload = { filename: trackedFilename, csv_content: csvContent, type: 'tracked' };
            
            if (isManual) {
                showStatus('Saving...', 'blue');
                saveProgressButton.disabled = true;
            } else {
                 showStatus('Auto-saving...', 'blue');
            }

            try {
                const response = await fetch(SAVE_WORKOUT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const result = await response.json();
                const message = response.ok ? (isManual ? `Progress saved!` : `Auto-saved.`) : `Error: ${result.message}`;
                showStatus(message, response.ok ? 'green' : 'red');
            } catch (error) {
                showStatus('Error: Could not connect to server.', 'red');
            } finally {
                if (isManual) saveProgressButton.disabled = false;
            }
        }
        
        async function handleCompleteWorkout() {
            if (!confirm("Are you sure you want to complete this workout? The plan will be archived.")) return;

            await autoSaveProgress(true);

            showStatus('Completing and archiving...', 'blue');
            completeWorkoutButton.disabled = true;
            saveProgressButton.disabled = true;

            try {
                const payload = {
                    tracked_filename: trackedFilename,
                    plan_filename: sourcePlanFilename
                };
                const response = await fetch(COMPLETE_WORKOUT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (response.ok) {
                    showStatus('Workout complete and plan archived!', 'green');
                    trackerContainer.innerHTML = `<div class="text-center py-16 text-green-600 bg-white rounded-xl shadow-lg border"><p class="text-2xl font-bold">Workout Complete!</p></div>`;
                    actionButtons.classList.add('hidden');
                    loadWorkoutListFromServer();
                } else {
                    showStatus(`Completion Error: ${result.message}`, 'red');
                    completeWorkoutButton.disabled = false;
                    saveProgressButton.disabled = false;
                }
            } catch (error) {
                showStatus('Error: Could not connect to server to complete workout.', 'red');
                completeWorkoutButton.disabled = false;
                saveProgressButton.disabled = false;
            }
        }

        function readDataFromUI() {
            const data = [];
            try {
                trackerContainer.querySelectorAll('.exercise-container').forEach((container) => {
                    const coachNotesEl = container.querySelector('blockquote');
                    const weightMatch = container.querySelector('p.text-sm.text-gray-600 span').textContent.match(/@ ([\d\.]+) kg/);
                    const weight = weightMatch ? parseFloat(weightMatch[1]) : 0;

                    const exerciseData = {
                        name: container.querySelector('h3').textContent,
                        targetReps: container.querySelector('.reps-input').previousElementSibling.textContent.replace('Goal: ', ''),
                        weight: weight,
                        supersetGroup: container.querySelector('p.text-indigo-600') ? container.querySelector('p.text-indigo-600').textContent.replace('Superset ', '') : 'None',
                        coachNotes: coachNotesEl ? coachNotesEl.textContent : '',
                        setsData: []
                    };
                    container.querySelectorAll('tbody tr').forEach(row => {
                        exerciseData.setsData.push({
                            reps: row.querySelector('.reps-input').value,
                            actualWeight: row.querySelector('.weight-input').value,
                            notes: row.querySelector('.notes-input').value,
                            rir: row.querySelector('.rir-input').value
                        });
                    });
                    data.push(exerciseData);
                });
            } catch (error) {
                console.error("Error reading data from UI:", error);
                showStatus("Error reading form data. Check console.", "red");
                return [];
            }
            return data;
        }

        function showStatus(message, color) {
            statusMessage.textContent = message;
            statusMessage.className = `text-sm font-medium h-5 text-${color}-600`;
            if (color === 'green' || color === 'red' || color === 'orange') {
                setTimeout(() => { if (statusMessage.textContent === message) statusMessage.textContent = ''; }, 4000);
            }
        }
    </script>
</body>
</html>

